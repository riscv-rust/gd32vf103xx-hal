#![allow(named_asm_labels)]

use core::arch::global_asm;

global_asm!(
    ".equ LOG_REGBYTES, 2",
    ".equ REGBYTES, 1 << LOG_REGBYTES",
    ".equ MSTATUS_MIE, 0x00000008",
    //
    ".macro DISABLE_MIE",
        "csrc mstatus, MSTATUS_MIE",
    ".endm",
    //
    ".macro SAVE_CONTEXT",
        //
        "addi sp, sp, -20*REGBYTES",
        //
        "sw x1, 0*REGBYTES(sp)",
        "sw x4, 1*REGBYTES(sp)",
        "sw x5, 2*REGBYTES(sp)",
        "sw x6, 3*REGBYTES(sp)",
        "sw x7, 4*REGBYTES(sp)",
        "sw x10, 5*REGBYTES(sp)",
        "sw x11, 6*REGBYTES(sp)",
        "sw x12, 7*REGBYTES(sp)",
        "sw x13, 8*REGBYTES(sp)",
        "sw x14, 9*REGBYTES(sp)",
        "sw x15, 10*REGBYTES(sp)",
        "sw x16, 11*REGBYTES(sp)",
        "sw x17, 12*REGBYTES(sp)",
        "sw x28, 13*REGBYTES(sp)",
        "sw x29, 14*REGBYTES(sp)",
        "sw x30, 15*REGBYTES(sp)",
        "sw x31, 16*REGBYTES(sp)",
    ".endm",
    //
    ".macro RESTORE_CONTEXT",
        "lw x1, 0*REGBYTES(sp)",
        "lw x4, 1*REGBYTES(sp)",
        "lw x5, 2*REGBYTES(sp)",
        "lw x6, 3*REGBYTES(sp)",
        "lw x7, 4*REGBYTES(sp)",
        "lw x10, 5*REGBYTES(sp)",
        "lw x11, 6*REGBYTES(sp)",
        "lw x12, 7*REGBYTES(sp)",
        "lw x13, 8*REGBYTES(sp)",
        "lw x14, 9*REGBYTES(sp)",
        "lw x15, 10*REGBYTES(sp)",
        "lw x16, 11*REGBYTES(sp)",
        "lw x17, 12*REGBYTES(sp)",
        "lw x28, 13*REGBYTES(sp)",
        "lw x29, 14*REGBYTES(sp)",
        "lw x30, 15*REGBYTES(sp)",
        "lw x31, 16*REGBYTES(sp)",
        // De-allocate the stack space
        "addi sp, sp, 20*REGBYTES",
    ".endm",
    //
    ".section .text.irq",
    ".option push",
    ".option norelax",
    ".align 2",
    ".option pop",
    ".global _irq_handler",
    "_irq_handler:",
        "SAVE_CONTEXT",
        //
        // The special CSR read operation, which actually uses mcause as operand
        // to directly store it to memory
        "csrrwi x0, 0x7ee, 17",
        // The special CSR read operation, which actually uses mepc as operand
        // to directly store it to memory
        "csrrwi x0, 0x7ef, 18",
        // The special CSR read operation, which actually uses msubm as operand
        // to directly store it to memory
        "csrrwi x0, 0x7eb, 19",
        //
        // The special CSR read/write operation, which is actually Claim the CLIC to
        // find its pending highest ID, if the ID is not 0, then automatically enable
        // the mstatus.MIE, and jump to its vector-entry-label, and update the link register.
        "csrrw ra, 0x7ed, ra",
        //
        "DISABLE_MIE",
        //
        "lw x5, 19*REGBYTES(sp)",
        // Load x5 value into PUSHMSUBM system status register
        "csrw 0x7eb, x5",
        "lw x5, 18*REGBYTES(sp)",
        "csrw mepc, x5",
        "lw x5, 17*REGBYTES(sp)",
        "csrw mcause, x5",
        //
        "RESTORE_CONTEXT",
        //
        "mret",
    //
    ".section .text.vectors, \"ax\"",
    ".option push",
    ".option norelax",
    ".align 9",
    ".option pop",
    "vectors:",
        ".word     0",
        ".word     0",
        ".word     0",
        ".word     INT_SFT",
        ".word     0",
        ".word     0",
        ".word     0",
        ".word     INT_TMR",
        ".word     0",
        ".word     0",
        ".word     0",
        ".word     0",
        ".word     0",
        ".word     0",
        ".word     0",
        ".word     0",
        ".word     0",
        ".word     INT_BWEI",
        ".word     INT_PMOVI",
        ".word     WWDGT",
        ".word     EXTI_LVD",
        ".word     TAMPER",
        ".word     RTC",
        ".word     FMC",
        ".word     RCU",
        ".word     EXTI_LINE0",
        ".word     EXTI_LINE1",
        ".word     EXTI_LINE2",
        ".word     EXTI_LINE3",
        ".word     EXTI_LINE4",
        ".word     DMA0_CHANNEL0",
        ".word     DMA0_CHANNEL1",
        ".word     DMA0_CHANNEL2",
        ".word     DMA0_CHANNEL3",
        ".word     DMA0_CHANNEL4",
        ".word     DMA0_CHANNEL5",
        ".word     DMA0_CHANNEL6",
        ".word     ADC0_1",
        ".word     CAN0_TX",
        ".word     CAN0_RX0",
        ".word     CAN0_RX1",
        ".word     CAN0_EWMC",
        ".word     EXTI_LINE9_5",
        ".word     TIMER0_BRK",
        ".word     TIMER0_UP",
        ".word     TIMER0_TRG_CMT",
        ".word     TIMER0_CHANNEL",
        ".word     TIMER1",
        ".word     TIMER2",
        ".word     TIMER3",
        ".word     I2C0_EV",
        ".word     I2C0_ER",
        ".word     I2C1_EV",
        ".word     I2C1_ER",
        ".word     SPI0",
        ".word     SPI1",
        ".word     USART0",
        ".word     USART1",
        ".word     USART2",
        ".word     EXTI_LINE15_10",
        ".word     RTC_ALARM",
        ".word     USBFS_WKUP",
        ".word     0",
        ".word     0",
        ".word     0",
        ".word     0",
        ".word     0",
        ".word     EXMC", // not present in Reference Manual but present in vendor HAL
        ".word     0",
        ".word     TIMER4",
        ".word     SPI2",
        ".word     UART3",
        ".word     UART4",
        ".word     TIMER5",
        ".word     TIMER6",
        ".word     DMA1_CHANNEL0",
        ".word     DMA1_CHANNEL1",
        ".word     DMA1_CHANNEL2",
        ".word     DMA1_CHANNEL3",
        ".word     DMA1_CHANNEL4",
        ".word     0",
        ".word     0",
        ".word     CAN1_TX",
        ".word     CAN1_RX0",
        ".word     CAN1_RX1",
        ".word     CAN1_EWMC",
        ".word     USBFS",
    //
    ".section .trap, \"ax\"",
    ".option push",
    ".option norelax",
    ".align 6",
    ".option pop",
    ".global _start_trap",
    "_start_trap:",
        "addi sp, sp, -16*REGBYTES",
        //
        "sw ra, 0*REGBYTES(sp)",
        "sw t0, 1*REGBYTES(sp)",
        "sw t1, 2*REGBYTES(sp)",
        "sw t2, 3*REGBYTES(sp)",
        "sw t3, 4*REGBYTES(sp)",
        "sw t4, 5*REGBYTES(sp)",
        "sw t5, 6*REGBYTES(sp)",
        "sw t6, 7*REGBYTES(sp)",
        "sw a0, 8*REGBYTES(sp)",
        "sw a1, 9*REGBYTES(sp)",
        "sw a2, 10*REGBYTES(sp)",
        "sw a3, 11*REGBYTES(sp)",
        "sw a4, 12*REGBYTES(sp)",
        "sw a5, 13*REGBYTES(sp)",
        "sw a6, 14*REGBYTES(sp)",
        "sw a7, 15*REGBYTES(sp)",
        //
        "add a0, sp, zero",
        "jal ra, _start_trap_rust",
        //
        "lw ra, 0*REGBYTES(sp)",
        "lw t0, 1*REGBYTES(sp)",
        "lw t1, 2*REGBYTES(sp)",
        "lw t2, 3*REGBYTES(sp)",
        "lw t3, 4*REGBYTES(sp)",
        "lw t4, 5*REGBYTES(sp)",
        "lw t5, 6*REGBYTES(sp)",
        "lw t6, 7*REGBYTES(sp)",
        "lw a0, 8*REGBYTES(sp)",
        "lw a1, 9*REGBYTES(sp)",
        "lw a2, 10*REGBYTES(sp)",
        "lw a3, 11*REGBYTES(sp)",
        "lw a4, 12*REGBYTES(sp)",
        "lw a5, 13*REGBYTES(sp)",
        "lw a6, 14*REGBYTES(sp)",
        "lw a7, 15*REGBYTES(sp)",
        //
        "addi sp, sp, 16*REGBYTES",
        "mret",
    //
    ".section .text",
    ".global _setup_interrupts",
    "_setup_interrupts:",
        // Set the the NMI base to share with mtvec by setting CSR_MMISC_CTL
        "li t0, 0x200",
        "csrs 0x7d0, t0",
        //
        // Set the mtvt
        "la t0, vectors",
        "csrw 0x307, t0",
        //
        // Set the mtvt2 and enable it
        "la t0, _irq_handler",
        "csrw 0x7ec, t0",
        "csrs 0x7ec, 0x1",
        //
        // Enable ECLIC and set trap handler
        "la t0, _start_trap",
        "andi t0, t0, -64",
        "ori t0, t0, 3",
        "csrw mtvec, t0",
        //
        "ret",
    options(raw),
);
